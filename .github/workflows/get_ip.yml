name: Get IP and Update Cloudflare DNS

###############################################################
#                   âš™ï¸ ä½¿ç”¨å‰é…ç½®è¯´æ˜                          #
# 1ï¸âƒ£ ä»“åº“ Settings > Secrets ä¸­æ·»åŠ ï¼š
#    - CLOUDFLARE_API_TOKEN : Cloudflare API ä»¤ç‰Œ
#    - SERVER_JIANG_KEY : Serveré…±çš„SCKEYï¼ˆå¯é€‰ï¼‰
# 2ï¸âƒ£ ä¿®æ”¹ DOMAIN å’Œ SUB_DOMAIN ä¸ºä½ çš„å®é™…åŸŸå
###############################################################

on:
  schedule:
    - cron: '0 */3 * * *'   # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
      timezone: Asia/Shanghai
  workflow_dispatch:          # å…è®¸æ‰‹åŠ¨è§¦å‘

jobs:
  get_and_update:
    runs-on: ubuntu-latest

    steps:
    # ==================== åˆå§‹åŒ– ====================
    - name: Check out code
      uses: actions/checkout@v3

    # ==================== Pythonç¯å¢ƒ ====================
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests

    # ==================== æ‰«æå¯ç”¨IP ====================
    - name: Run IP fetching script (Port 6000)
      id: fetch_ips
      run: |
        import requests
        import ipaddress
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import json

        def test_port(ip, port=6000):
            try:
                r = requests.get(f'http://{ip}:{port}/status', timeout=2)
                return r.status_code == 200
            except:
                return False

        def fetch_available_ips(ip_ranges):
            available_ips = []
            with ThreadPoolExecutor(max_workers=20) as executor:
                futures = {
                    executor.submit(test_port, str(ip)): str(ip)
                    for ip_range in ip_ranges
                    for ip in ipaddress.IPv4Network(ip_range)
                }
                for future in as_completed(futures):
                    ip = futures[future]
                    if future.result():
                        available_ips.append(ip)
                        print(f"âœ… {ip} å¯ç”¨")
            return available_ips

        if __name__ == "__main__":
            ip_ranges = [
                "118.79.113.0/24",
                "118.79.114.0/24",
                "183.188.22.0/24",
                "171.119.205.0/24",
                "116.179.130.0/24",
                "118.79.119.0/24",
                "118.79.139.0/24",
                "171.119.206.0/24",
                "171.125.90.0/24",
                "183.188.20.0/24",
                "118.79.12.0/24",
                "183.188.159.0/24"
            ]

            available_ips = fetch_available_ips(ip_ranges)
            print(f"\nå…±æ‰¾åˆ° {len(available_ips)} ä¸ªå¯ç”¨ IP")
            
            if available_ips:
                with open('available_ips.json', 'w') as f:
                    json.dump(available_ips, f)
            else:
                print("no_available_ips=true")
      shell: python

    - name: Check if IPs were found
      id: check_ips
      run: |
        if [ ! -f available_ips.json ]; then
          echo "no_available_ips=true" >> $GITHUB_ENV
        else
          echo "no_available_ips=false" >> $GITHUB_ENV
        fi

    # ==================== æ›´æ–° Cloudflare DNS ====================
    - name: Update Cloudflare DNS
      if: env.no_available_ips == 'false'
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        DOMAIN: "wekh.qzz.io"     # â† ä¿®æ”¹ä¸ºä½ çš„ä¸»åŸŸå
        SUB_DOMAIN: "zb"          # â† ä¿®æ”¹ä¸ºä½ çš„å­åŸŸå
      run: |
        cat << 'EOF' > updateDNS.js
        const fs = require('fs');
        const axios = require('axios');

        if (!process.env.CLOUDFLARE_API_TOKEN) {
          console.error('âŒ æœªæ£€æµ‹åˆ° CLOUDFLARE_API_TOKEN');
          process.exit(1);
        }

        const CLOUDFLARE_API_TOKEN = process.env.CLOUDFLARE_API_TOKEN;
        const DOMAIN = process.env.DOMAIN;
        const SUB_DOMAIN = process.env.SUB_DOMAIN;
        const FULL_DOMAIN = `${SUB_DOMAIN}.${DOMAIN}`;
        const CLOUDFLARE_API_URL = 'https://api.cloudflare.com/client/v4';
        const headers = {
          'Authorization': `Bearer ${CLOUDFLARE_API_TOKEN}`,
          'Content-Type': 'application/json'
        };

        const availableIps = JSON.parse(fs.readFileSync('./available_ips.json', 'utf8'));
        console.log('=== å¯ç”¨ IP åˆ—è¡¨ ===');
        availableIps.forEach(ip => console.log('â†’', ip));

        async function getZoneId() {
          const res = await axios.get(`${CLOUDFLARE_API_URL}/zones?name=${DOMAIN}`, { headers });
          return res.data.result[0].id;
        }

        async function getDnsRecords(zoneId) {
          const res = await axios.get(
            `${CLOUDFLARE_API_URL}/zones/${zoneId}/dns_records?type=A&name=${FULL_DOMAIN}`,
            { headers }
          );
          return res.data.result;
        }

        async function updateDns(zoneId, recordId, ip) {
          await axios.put(
            `${CLOUDFLARE_API_URL}/zones/${zoneId}/dns_records/${recordId}`,
            { type: 'A', name: SUB_DOMAIN, content: ip, ttl: 1, proxied: false },
            { headers }
          );
          console.log(`âœ… æ›´æ–°: ${ip}`);
        }

        async function createDns(zoneId, ip) {
          await axios.post(
            `${CLOUDFLARE_API_URL}/zones/${zoneId}/dns_records`,
            { type: 'A', name: SUB_DOMAIN, content: ip, ttl: 1, proxied: false },
            { headers }
          );
          console.log(`ğŸ†• åˆ›å»º: ${ip}`);
        }

        async function main() {
          try {
            const zoneId = await getZoneId();
            const records = await getDnsRecords(zoneId);

            console.log(`\nå½“å‰è®°å½•æ•°: ${records.length}`);
            console.log(`è®¡åˆ’æ›´æ–°: ${availableIps.length} ä¸ª IP`);

            for (let i = 0; i < availableIps.length; i++) {
              const ip = availableIps[i];
              if (records[i]) {
                await updateDns(zoneId, records[i].id, ip);
              } else {
                await createDns(zoneId, ip);
              }
            }

            // åˆ é™¤å¤šä½™è®°å½•
            if (records.length > availableIps.length) {
              const extra = records.slice(availableIps.length);
              for (const rec of extra) {
                await axios.delete(`${CLOUDFLARE_API_URL}/zones/${zoneId}/dns_records/${rec.id}`, { headers });
                console.log(`ğŸ—‘ åˆ é™¤: ${rec.content}`);
              }
            }

            const finalRecords = await getDnsRecords(zoneId);
            console.log('\n=== å½“å‰ DNS è®°å½• ===');
            finalRecords.forEach(r => console.log(`${r.name} â†’ ${r.content}`));
          } catch (e) {
            console.error('âŒ å‡ºé”™:', e.response?.data || e.message);
            process.exit(1);
          }
        }

        main();
        EOF

        npm install axios --silent
        node updateDNS.js

    # ==================== é€šçŸ¥éƒ¨åˆ† ====================
    - name: Notify if no IPs found
      if: env.no_available_ips == 'true'
      env:
        SERVER_JIANG_KEY: ${{ secrets.SERVER_JIANG_KEY }}
      run: |
        if [ -n "$SERVER_JIANG_KEY" ]; then
          curl -sS \
            --data "text=æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„ IP åœ°å€" \
            --data "desp=æ£€æµ‹ç«¯å£: 6000ï¼Œè¯·æ£€æŸ¥ IP æ®µé…ç½®" \
            "https://sctapi.ftqq.com/$SERVER_JIANG_KEY.send"
        else
          echo "æœªé…ç½® SERVER_JIANG_KEYï¼Œè·³è¿‡é€šçŸ¥"
        fi
