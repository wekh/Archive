name: Get IP and Update Cloudflare DNS

###############################################################
#                   !!! é‡è¦å‰ç½®è¯´æ˜ !!!                      #
# ä½¿ç”¨å‰å¿…é¡»ï¼š                                                 #
# 1. åœ¨ä»“åº“ Settings > Secrets ä¸­é…ç½®ï¼š                        #
#    - CLOUDFLARE_API_TOKEN : Cloudflare APIä»¤ç‰Œ               #
#    - SERVER_JIANG_KEY : Serveré…±çš„SCKEYï¼ˆå¯é€‰ï¼‰               #
# 2. ä¿®æ”¹ä¸‹æ–¹ DOMAIN å’Œ SUB_DOMAIN ä¸ºæ‚¨çš„å®é™…åŸŸå              #
###############################################################

on:
  schedule:
    - cron: '0 */3 * * *'  # æ¯3å°æ—¶è¿è¡Œä¸€æ¬¡
      timezone: Asia/Shanghai
  workflow_dispatch:       # å…è®¸æ‰‹åŠ¨è§¦å‘

jobs:
  get_and_update:
    runs-on: ubuntu-latest

    steps:
    # ==================== åˆå§‹åŒ– ====================
    - name: Check out code
      uses: actions/checkout@v3

    # ==================== Pythonç¯å¢ƒè®¾ç½® ====================
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests

    # ==================== IPæ‰«æéƒ¨åˆ† ====================
    - name: Run IP fetching script (Port 6000)
      id: fetch_ips
      run: |
        import requests
        import ipaddress
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import json
        import random

        def test_port(ip, port=6000):
            try:
                response = requests.get(f'http://{ip}:{port}/status', timeout=2)
                return response.status_code == 200
            except:
                return False

        def fetch_available_ips(ip_ranges):
            available_ips = []
            with ThreadPoolExecutor(max_workers=20) as executor:
                future_to_ip = {
                    executor.submit(test_port, str(ip)): str(ip)
                    for ip_range in ip_ranges
                    for ip in ipaddress.IPv4Network(ip_range)
                }
                for future in as_completed(future_to_ip):
                    if future.result():
                        available_ips.append(future_to_ip[future])
            return available_ips

        if __name__ == "__main__":
            # è¦æ‰«æçš„IPæ®µï¼ˆå¯æ ¹æ®éœ€è¦ä¿®æ”¹ï¼‰
            ip_ranges = [
                "118.79.113.0/24",
                "118.79.114.0/24",
                "183.188.22.0/24",
                "171.119.205.0/24",
                "116.179.130.0/24",
                "118.79.119.0/24",
                "118.79.139.0/24",
                "171.119.206.0/24",
                "171.125.90.0/24",
                "183.188.20.0/24",
                "183.188.159.0/24"
            ]
            
            available_ips = fetch_available_ips(ip_ranges)
            print(f"æ‰¾åˆ° {len(available_ips)} ä¸ªå¯ç”¨IP")
            
            if available_ips:
                with open('available_ips.json', 'w') as f:
                    json.dump(available_ips, f)
            else:
                print("no_available_ips=true")
      shell: python

    - name: Check if IPs were found
      id: check_ips
      run: |
        if [ ! -f available_ips.json ]; then
          echo "no_available_ips=true" >> $GITHUB_ENV
        else
          echo "no_available_ips=false" >> $GITHUB_ENV
        fi

    # ==================== Cloudflare DNSæ›´æ–° ====================
    - name: Update Cloudflare DNS
      if: env.no_available_ips == 'false'
      env:
        # å¿…éœ€ï¼šåœ¨ä»“åº“Secretsä¸­é…ç½®CLOUDFLARE_API_TOKEN
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        # ä¿®æ”¹ä¸ºæ‚¨çš„åŸŸåå’Œå­åŸŸå â†“
        DOMAIN: "wekh.eu.org"    # ä¸»åŸŸåï¼ˆéœ€ä¿®æ”¹ï¼‰
        SUB_DOMAIN: "zb"        # å­åŸŸåï¼ˆéœ€ä¿®æ”¹ï¼‰
      run: |
        cat << 'EOF' > updateDNS.js
        const fs = require('fs');
        const axios = require('axios');

        // é…ç½®éªŒè¯
        if (!process.env.CLOUDFLARE_API_TOKEN) {
            console.error('âŒ é”™è¯¯ï¼šæœªæ£€æµ‹åˆ°CLOUDFLARE_API_TOKEN');
            process.exit(1);
        }

        const CLOUDFLARE_API_TOKEN = process.env.CLOUDFLARE_API_TOKEN;
        const DOMAIN = process.env.DOMAIN;
        const SUB_DOMAIN = process.env.SUB_DOMAIN;
        const FULL_DOMAIN = `${SUB_DOMAIN}.${DOMAIN}`;

        console.log('=== å¼€å§‹DNSæ›´æ–°æµç¨‹ ===');
        console.log(`ç›®æ ‡åŸŸå: ${FULL_DOMAIN}`);

        // è¯»å–å¯ç”¨IP
        const availableIps = JSON.parse(fs.readFileSync('./available_ips.json', 'utf8'));
        console.log('å¯ç”¨IPåˆ—è¡¨:', availableIps);

        const CLOUDFLARE_API_URL = 'https://api.cloudflare.com/client/v4';
        const headers = {
            'Authorization': `Bearer ${CLOUDFLARE_API_TOKEN}`,
            'Content-Type': 'application/json'
        };

        // éšæœºé€‰æ‹©ä¸¤ä¸ªIPï¼ˆå…è®¸é‡å¤ï¼‰
        function selectIps(ipList) {
            if (ipList.length === 0) return [];
            const shuffled = [...ipList].sort(() => 0.5 - Math.random());
            return [shuffled[0], shuffled.length > 1 ? shuffled[1] : shuffled[0]];
        }

        async function getZoneId() {
            const res = await axios.get(`${CLOUDFLARE_API_URL}/zones?name=${DOMAIN}`, { headers });
            return res.data.result[0].id;
        }

        async function getDnsRecords(zoneId) {
            const res = await axios.get(
                `${CLOUDFLARE_API_URL}/zones/${zoneId}/dns_records?type=A&name=${FULL_DOMAIN}`,
                { headers }
            );
            return res.data.result;
        }

        async function updateDns(zoneId, recordId, ip) {
            try {
                await axios.put(
                    `${CLOUDFLARE_API_URL}/zones/${zoneId}/dns_records/${recordId}`,
                    {
                        type: 'A',
                        name: SUB_DOMAIN,
                        content: ip,
                        ttl: 1,  // è‡ªåŠ¨TTL
                        proxied: false
                    },
                    { headers }
                );
                console.log(`âœ… è®°å½•æ›´æ–°æˆåŠŸ: ${ip}`);
            } catch (error) {
                if (error.response?.data?.errors?.[0]?.code === 81058) {
                    console.log(`â© IPæœªå˜åŒ–: ${ip}`);
                } else {
                    throw error;
                }
            }
        }

        async function createDns(zoneId, ip) {
            await axios.post(
                `${CLOUDFLARE_API_URL}/zones/${zoneId}/dns_records`,
                {
                    type: 'A',
                    name: SUB_DOMAIN,
                    content: ip,
                    ttl: 1,  // è‡ªåŠ¨TTL
                    proxied: false
                },
                { headers }
            );
            console.log(`ğŸ†• è®°å½•åˆ›å»ºæˆåŠŸ: ${ip}`);
        }

        async function main() {
            try {
                const zoneId = await getZoneId();
                const records = await getDnsRecords(zoneId);
                const [ip1, ip2] = selectIps(availableIps);

                console.log('\n=== å°†æ›´æ–°ä¸ºä»¥ä¸‹IP ===');
                console.log(`ä¸»IP: ${ip1}`);
                console.log(`å¤‡ç”¨IP: ${ip2}`);

                // æ›´æ–°/åˆ›å»ºè®°å½•
                if (records.length > 0) {
                    await updateDns(zoneId, records[0].id, ip1);
                } else {
                    await createDns(zoneId, ip1);
                }

                if (records.length > 1) {
                    await updateDns(zoneId, records[1].id, ip2);
                } else if (ip1 !== ip2) {
                    await createDns(zoneId, ip2);
                }

                // éªŒè¯ç»“æœ
                const finalRecords = await getDnsRecords(zoneId);
                console.log('\n=== å½“å‰DNSè®°å½• ===');
                finalRecords.forEach(r => console.log(`${r.name}: ${r.content}`));

            } catch (error) {
                console.error('âŒ å‘ç”Ÿé”™è¯¯:', error.response?.data || error.message);
                process.exit(1);
            }
        }

        main();
        EOF

        # å®‰è£…ä¾èµ–å¹¶æ‰§è¡Œ
        npm install axios --silent
        node updateDNS.js

    # ==================== é€šçŸ¥éƒ¨åˆ† ====================
    - name: Notify if no IPs found
      if: env.no_available_ips == 'true'
      env:
        # å¯é€‰ï¼šåœ¨ä»“åº“Secretsä¸­é…ç½®SERVER_JIANG_KEY
        SERVER_JIANG_KEY: ${{ secrets.SERVER_JIANG_KEY }}
      run: |
        if [ -n "$SERVER_JIANG_KEY" ]; then
          curl -sS \
            --data "text=æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„ IP åœ°å€" \
            --data "desp=æ£€æµ‹ç«¯å£: 6000ï¼Œè¯·æ£€æŸ¥ IP æ®µé…ç½®" \
            "https://sctapi.ftqq.com/$SERVER_JIANG_KEY.send"
        else
          echo "æœªé…ç½®SERVER_JIANG_KEYï¼Œè·³è¿‡é€šçŸ¥"
        fi
